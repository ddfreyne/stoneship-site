---
title: Module systems in programming languages
updated_at: 2021-05-08 08:37:40.000000000 +02:00
tags:
- "#public"
---


Modern programming languages have module systems and package managers, for easy structuring of large applications and reusing source code. There are plenty different ways in which such module systems can work, though, and this note attempts to describe some of the ideas.

Some definitions[^definitions]:

* A **module** is the smallest collection of independent units (functions, constants, structs, classes, and more). It often corresponds to a file, but not always. For example, a `math` module could contain all basic math functions and constants.

* A **package** is a collection of related modules. It is independently distributable. For example, a `stdlib` module could contain all basic modules that would be expected from a programming language (IO, string manipulation, math, and more).

* An **import statement** is a source code construct that makes the code in a module available in the current file, module, or scope.

[^definitions]: The terms “module” and “package” are not always used this way. For example, Java (with its new module system) has swapped the two.

## Locations
A nontrivial module will load reusable source code from three places:

* The standard library
* Installed packages
* The local package

The local package refers to the product that’s being developed, and that contains the module that does the importing.

In my opinion, it is important to be clear where an import statement loads modules from:

* C (despite its archaic approach modularity) distinguishes between imports in the local package (`#include "mymodule.h"`) and standard library or installed packages (`#include <stdbool.h>`).

* Ruby’s `#require` can load from anywhere, depending on the load path (a search path, set as an environment variable). It does have `#require_relative`, which indicates an import from the local package.

* Dart distinguishes between all three by having `import 'dart:async'` (prefix `dart:`) for standard library imports, `import 'package:something'` (prefix `package:`) for package imports, and `import 'myfile'` for local imports.

## What are modules?
Modules can be files, which is the simplest approach. They don’t have to be, though.

::**To do**: How are module names derived? It can be the file path itself (like JavaScript), or defined in the file (like Go).::

## Visibility
::**To do**: Private by default, with export keyword? Go-style public/private? Underscore for private?::

::**To do**: Re-exports: how do those work?::

## Miscellaneous
* An import statement should not modify the global namespace. This is what Ruby does and leads to weird effects: if I import a package that imports the `yaml` package, I can use the functionality from the `yaml` package without having imported it.

* The import syntax for a package needs to follow the package name. Python does not do this, so you can install a package with one name and then import it with the other—very confusing.

* JavaScript (or at least Webpack) allows importing non-source files (e.g., CSS). I find this super interesting. Unfortunately, the Webpack configuration to make that work is too opaque, but a language with built-in support for this (with zero configuration) would be nice to have.

* ::**To do**: Aliasing (import x as y), partial imports (from x import xyz, import x for xyz). Full imports (Python-like star imports) are bad!::

* ::**To do**: Needs a package manager, with checksums. Perhaps with vendoring/caching support. Probably needs a way to bundle all dependencies together.::

* ::**To do**: If a package is imported, it’s nice to be able to have multiple versions of it. JavaScript’s npm ecosystem allows this.::

* ::**To do**: Inline package manager::